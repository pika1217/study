---
title: 浏览器渲染
date: 2017-8-12
tags: 浏览器渲染
categories: 前端综合
---
## 浏览器渲染过程
当浏览器获得一个html文件时，会“自上而下”加载，并在加载过程中进行解析渲染。
解析：
1. 浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。
2. 将CSS解析成 CSS Rule Tree 。
3. 根据DOM树和CSS Rule来构造 Rendering Tree。注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像 Header 或 display:none 的东西就没必要放在渲染树中了。
4. 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为Layout，顾名思义就是计算出每个节点在屏幕中的位置。
5. 再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。

上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。

## 回流和重汇
1. 回流：浏览器要花时间去渲染，当它发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。一个元素的回流导致了其所有子元素以及DOM中紧随其后的祖先元素的随后的回流。
2. 重汇：如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的repaint，重画某一部分。重绘的代价是高昂的，因为浏览器必须验证DOM树上其他节点元素的可见性。

Reflow要比Repaint更花费时间，也就更影响性能。所以在写代码的时候，要尽量避免过多的Reflow。
>reflow的原因：

（1）页面初始化的时候；

（2）操作DOM时；

（3）某些元素的尺寸变了；

（4）如果 CSS 的属性发生变化了。

（5）改变窗口大小

（6）计算offsetWidth 和offsetHeight等属性

>减少 reflow/repaint

　（1）不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。

　（2）不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。

　（3）为动画的使用 fixed 或 absoult 的 position，那么它们不影响其它元素的布局，修改他们的 CSS 是不会 reflow 的。

　（4）千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。
　
　（5）“离线”的批量改变和表现DOM。“离线”意味着不在当前的DOM树中做修改。你可以：通过documentFragment来保留临时变动。
　（6）
## Javascript的加载和执行的特点：
（1）载入后马上执行；

（2）执行时会阻塞页面后续的内容（包括页面的渲染、其它资源的下载）。

原因：因为浏览器需要一个稳定的DOM树结构，而JS中很有可能有 代码直接改变了DOM树结构，比如使用 document.write 或 appendChild,甚至是直接使用的location.href进行跳转，浏览器为了防止出现JS修 改DOM树，需要重新构建DOM树的情况，所以 就会阻塞其他的下载和呈现。
转:http://blog.csdn.net/xiaozhuxmen/article/details/52014901

